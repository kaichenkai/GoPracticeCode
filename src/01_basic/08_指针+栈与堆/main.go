package main

import "fmt"

//对于指针类型，需要知道：指针地址 和 指针取值
/*
	指针地址：每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置，使用 & 放在变量前面进行“取指针地址”操作
	指针取值：使用 * 方便指针地址前面进行“指针取值”操作
 */


//创建指针的另一种方法
/*
	new() 函数可以创建一个对应类型的指针，创建过程会分配内存，被创建的指针指向的值为默认值
 */


//栈与堆
/*
栈（Stack）是一种拥有特殊规则的线性表数据结构
只允许往线性表的一端放入数据，之后在这一端取出数据，按照后进先出（LIFO，Last InFirst Out）的顺序：
往栈中放入元素的过程叫做入栈，入栈会增加栈的元素数量，最后放入的元素总是位于栈的顶部，最先放入的元素总是位于栈的底部
从栈中取出元素时，只能从栈顶部取出，不允许从栈底获取数据，也不允许对栈成员进行任何查看和修改操作
 */


//什么是堆
/*
堆内存分配类似于往一个房间里摆放各种家具，家具的尺寸有大有小，分配内存时，需要找一块足够大小的空间来摆放家具，经过反复摆放和腾空家具后，房间里会变得乱七八糟，此时再往空间里摆放家具会存在虽然有足够的空间，但各空间分布在不同的区域，无法有一段连续的空间来摆放家具的问题，此时，内存分配器就需要对这些空间进行调整优化，如下图：

堆分配内存和栈分配内存相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片
堆和栈各有优缺点，该怎么在编程中处理这个问题呢？在 C/C++ 语言中，需要开发者自己学习如何进行内存分配，选用怎样的内存分配方式来适应不同的算法需求。比如，函数局部变量尽量使用栈；全局变量、结构体成员使用堆分配等。程序员不得不花费很多年的时间在不同的项目中学习、记忆这些概念并加以实践和使用。
Go 语言将这个过程整合到编译器中，命名为“变量逃逸分析”。这个技术由编译器分析代码的特征和代码生命期，决定应该如何堆还是栈进行内存分配，即使程序员使用 Go 语言完成了整个工程后也不会感受到这个过程

栈内存中通常分配【值类型】，包括 int,  float,  bool,  string 以及数组和 struct（结构体）
堆内存中通常分配【引用类型】，通过 GC 回收，包括 pointer,  select,  map,  chan 等
 */


func main(){
	//指针地址
	var a int = 10
	var addrA *int = &a
	fmt.Println("address: ", addrA)
	fmt.Printf("type: %T \n", addrA)

	//指针取值
	var b int = *addrA
	fmt.Println(b)

	//通过指针修改指针指向的值
	*addrA = 20
	fmt.Println(a)

	//new 指针
	var str *string = new(string)
	fmt.Println(*str)
	*str = "hello world"
	fmt.Println(*str)
}
